
pioche <- tous les hommes
tant que la pioche n'est pas vide faire
   on pioche un homme X
   soit x la prochaine femme à qui X doit faire une proposition
   si x n'est pas fiancée, x et X se fiancent
   sinon faire 
        x choisit un gagnant et un perdant entre X et son fiancé actuel
        le gagnant devient le fiancé de x
        le perdant avance son rang d'appel
        on defausse le perdant
    fin faire
fin tant que


//

let n = entree.n in
    let x = ref None in
    let _x = ref None in
    let res = ref [] in
    let hommes = ref [] in
    let omega = None in

    for i=0 to n-1 do
      hommes := i::!hommes;
    done;
    hommes := List.rev !hommes; (* <- init hommes [0;1;...;n-1]*) 
    
    
    let _pioche = P.of_list !hommes in

    (* fiancer toutes les femmes à Ω; *)
    
    let config = {
      rang_appel_de = Array.make n 0;
      fiance_de = Array.make n omega;
    } in
  
    x := P.pioche _pioche; (* <- homme pioché *)

    while !x <> None do
      _x := Some config.rang_appel_de.(Option.get !x);

      if config.fiance_de.(Option.get !_x) = None 
        then begin
          config.fiance_de.(Option.get !_x) <- !x
      end
      else begin
          let current_fiance = Option.get (config.fiance_de.(Option.get !_x)) in
          if entree.prefere.(Option.get !_x) (Option.get !x) current_fiance (* si x préfère X à son fiancé *)
            then begin
              config.fiance_de.(Option.get !_x) <- !x;
              config.rang_appel_de.(current_fiance) <- config.rang_appel_de.(current_fiance) + 1;
              P.defausse current_fiance _pioche;
            end
          else begin
            config.rang_appel_de.(Option.get !x) <- config.rang_appel_de.(Option.get !x) + 1;
          end
      end;
      
      x := P.pioche _pioche; (* maj homme pioché *)  
    done;

  
     (*célébrer n mariages*)
    for i=0 to n-1 do
      if (config.fiance_de.(i)) <> None 
        then begin
          res := (Option.get config.fiance_de.(i),(i:femme))::!res
        end
    done;
    !res